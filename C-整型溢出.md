# 整型溢出
## 无符号整型溢出
对于unsigned整型溢出, C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”, 
也就是说, 如果一个unsigned char (1字节, 8bits)溢出了, 会把溢出的值与256求模。
```C
#include <stdio.h>
int main(int argc, const char * argv[]) {
  // insert code here...
  unsigned char x;
  x = 128 + 130;
  printf("%d\n",x);  
}
```
上面代码会输出: 2, 258以256为模的结果值是2。

## 有符号整型溢出
对于signed整型的溢出, C的规范定义是***“undefined behavior(未定义行为)”***, 
虽然没有定义, 但是大部分编译器实现的溢出机制都是一样的。

> 注意: 下列例子只是经典实现, 但考虑到编译器的不同, 实际结果可能会出乎我们的预料
> 甚至编译器会自行优化, 将原有类型升级也不奇怪。
```C
signed char x;
x = 125 + 5;
```
上面代码会输出：-126, 因为130的二进制位为10000010, 符号为1, 表示负数。
对于有符号整型, 负数是用补码表示的, 即绝对值取反后加一。根据之前方法逆向回去, 
先减一后再取反得01111110, 即126.所以10000010表示的是-126。

```C
signed char x;
x = (-100) + (-100);
```
上面代码会输出56, 因为200的二进制为11001000, -200根据补码的算法, 得出00111000即56。
上面的两个例子无论是向上溢出还是向下溢出, 绝对值都在相对于无符号整型能表示的范围内。
对于signed char如果结果为400, 超出了位数表示范围, 取结果的低八位。

```C
signed char x;
x = 200 + 200;
```
因此上面代码会输出-112。如果x的结果为负数且超出了255, 则取结果的低八位, 
并进行补码的反向操作, 减一后取反。


# 常见溢出

```C
int a = 5000;
int b = 25;
long c = a * b; //a * b 以整型进行计算，结果为125000，在32位的机器上没问题，但在16位的机器上会导致溢出的现象。
···
/* 解决方法 */
long c = (long)a * b;//运算前先进行一次强制类型提升，结果为125000

```